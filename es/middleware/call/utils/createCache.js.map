{"version":3,"sources":["../../../../src/middleware/call/utils/createCache.js"],"names":["isServer","toAction","defaultCreateCacheKey","action","name","type","basename","location","pathname","search","callbacks","api","config","prev","Error","push","cache","options","createCacheKey","cacheStorage","isCached","route","req","path","undefined","key","getKind","isUniversal","cacheAction","clear","invalidator","opts","k","newCache","Object","assign","indexOf","act","names","concat","forEach"],"mappings":"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","sourcesContent":["import { isServer } from '@respond-framework/utils'\nimport { toAction } from '../../../utils'\n\nconst defaultCreateCacheKey = (action, name) => {\n  const { type, basename, location } = action\n  const { pathname, search } = location\n  return `${name}|${type}|${basename}|${pathname}|${search}` // don't cache using URL hash, as in 99.999% of all apps its the same route\n}\n\nconst callbacks = []\n\nexport default (api, name, config) => {\n  if (config.prev) {\n    throw new Error(\n      `[rudy] call('${name}') middleware 'cache' option cannot be used with 'prev' option`,\n    )\n  }\n\n  callbacks.push(name)\n  if (api.cache) return api.cache\n\n  const { createCacheKey = defaultCreateCacheKey } = api.options\n  const cache = (config.cacheStorage = config.cacheStorage || {})\n\n  const isCached = (name, route, req) => {\n    if (isServer()) return false\n\n    const { options, action } = req\n\n    if (!route.path || route.cache === false) return false\n    if (options.cache === false && route.cache === undefined) return false\n\n    const key = createCacheKey(action, name)\n\n    if (req.getKind() === 'load' && req.isUniversal()) {\n      cache[key] = true\n    }\n\n    if (cache[key]) return true\n\n    return false\n  }\n\n  const cacheAction = (name, action) => {\n    const key = createCacheKey(action, name)\n    cache[key] = true\n    return key\n  }\n\n  const clear = (invalidator, opts = {}) => {\n    if (!invalidator) {\n      for (const k in cache) delete cache[k]\n    } else if (typeof invalidator === 'function') {\n      // allow user to customize cache clearing algo\n      const newCache = invalidator(cache, api, opts) // invalidators should mutably operate on the cache hash\n      if (newCache) {\n        // but if they don't we'll merge into the same object reference\n        for (const k in cache) delete cache[k]\n        Object.assign(cache, newCache)\n      }\n    } else if (typeof invalidator === 'string') {\n      // delete all cached items for TYPE or other string\n      for (const k in cache) {\n        if (k.indexOf(invalidator) > -1) delete cache[k]\n      }\n    } else {\n      // delete all/some callbacks for precise item (default)\n      const action = invalidator\n      const act = toAction(api, action)\n      const names = opts.name === undefined ? callbacks : [].concat(opts.name)\n\n      names.forEach((name) => {\n        const key = createCacheKey(act, name)\n        delete cache[key]\n      })\n    }\n  }\n\n  return { isCached, cacheAction, clear }\n}\n"],"file":"createCache.js"}