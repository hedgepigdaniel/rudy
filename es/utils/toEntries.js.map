{"version":3,"sources":["../../src/utils/toEntries.js"],"names":["toAction","api","entries","index","n","isSingleEntry","length","map","e","undefined","Math","min","max","findInitialN","Array","isArray","type"],"mappings":";;AACA,SAASA,QAAT,QAAyB,SAAzB;AAGA,gBAAe,UACbC,GADa,EAEbC,OAFa,EAGbC,KAHa,EAIbC,CAJa,EAKV;AACHF,EAAAA,OAAO,GAAGG,aAAa,CAACH,OAAD,CAAb,GAAyB,CAACA,OAAD,CAAzB,GAAqCA,OAA/C;AACAA,EAAAA,OAAO,GAAGA,OAAO,CAACI,MAAR,KAAmB,CAAnB,GAAuB,CAAC,GAAD,CAAvB,GAA+BJ,OAAzC;AACAA,EAAAA,OAAO,GAAGA,OAAO,CAACK,GAAR,CAAY,UAACC,CAAD;AAAA,WAAOR,QAAQ,CAACC,GAAD,EAAMO,CAAN,CAAf;AAAA,GAAZ,CAAV;AAEAL,EAAAA,KAAK,GAAGA,KAAK,KAAKM,SAAV,GAAsBN,KAAtB,GAA8BD,OAAO,CAACI,MAAR,GAAiB,CAAvD,CALG,CAKsD;;AACzDH,EAAAA,KAAK,GAAGO,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,GAAL,CAAST,KAAT,EAAgB,CAAhB,CAAT,EAA6BD,OAAO,CAACI,MAAR,GAAiB,CAA9C,CAAR,CANG,CAMsD;;AAEzDF,EAAAA,CAAC,GAAGA,CAAC,IAAIS,YAAY,CAACV,KAAD,EAAQD,OAAR,CAArB,CARG,CAQmC;;AAEtC,SAAO;AAAEE,IAAAA,CAAC,EAADA,CAAF;AAAKD,IAAAA,KAAK,EAALA,KAAL;AAAYD,IAAAA,OAAO,EAAPA;AAAZ,GAAP;AACD,CAhBD,E,CAkBA;AACA;AACA;AACA;;AAEA,OAAO,IAAMW,YAAY,GAAG,SAAfA,YAAe,CAACV,KAAD,EAAgBD,OAAhB;AAAA,SAC1BC,KAAK,GAAG,CAAR,GAAY,CAAZ,GAAgBD,OAAO,CAACI,MAAR,GAAiB,CAAjB,GAAqB,CAAC,CAAtB,GAA0B,CADhB;AAAA,CAArB;;AAEP,IAAMD,aAAa,GAAG,SAAhBA,aAAgB,CAACG,CAAD;AAAA,SACpB,CAACM,KAAK,CAACC,OAAN,CAAcP,CAAd,CAAD,IACA;AACC,SAAOA,CAAC,CAAC,CAAD,CAAR,KAAgB,QAAhB,IAA4B,QAAOA,CAAC,CAAC,CAAD,CAAR,MAAgB,QAA5C,IAAwD,CAACA,CAAC,CAAC,CAAD,CAAD,CAAKQ,IAH3C;AAAA,CAAtB,C,CAGuE","sourcesContent":["// @flow\nimport { toAction } from './index'\nimport type { Route } from '../flow-types'\n\nexport default (\n  api: Route,\n  entries: Array<mixed>,\n  index: number,\n  n: ?number,\n) => {\n  entries = isSingleEntry(entries) ? [entries] : entries\n  entries = entries.length === 0 ? ['/'] : entries\n  entries = entries.map((e) => toAction(api, e))\n\n  index = index !== undefined ? index : entries.length - 1 // default to head of array\n  index = Math.min(Math.max(index, 0), entries.length - 1) // insure the index is in range\n\n  n = n || findInitialN(index, entries) // initial direction the user is going across the history track\n\n  return { n, index, entries }\n}\n\n// When entries are restored on load, the direction is always forward if on an index > 0\n// because the corresponding entries are removed (just like a `push`), and you are now at the head.\n// Otherwise, if there are multiple entries and you are on the first, you're considered\n// to be going back, but if there is one, you're logically going forward.\n\nexport const findInitialN = (index: number, entries: Array<mixed>) =>\n  index > 0 ? 1 : entries.length > 1 ? -1 : 1\nconst isSingleEntry = (e) =>\n  !Array.isArray(e) ||\n  // $FlowFixMe\n  (typeof e[0] === 'string' && typeof e[1] === 'object' && !e[1].type) // pattern match: [string, state]\n"],"file":"toEntries.js"}