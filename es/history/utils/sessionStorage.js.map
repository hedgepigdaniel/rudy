{"version":3,"sources":["../../../src/history/utils/sessionStorage.js"],"names":["toEntries","saveHistory","entries","map","e","location","url","state","key","set","restoreHistory","api","history","get","initializeHistory","index","getHistoryState","format","clear","window","sessionStorage","setItem","historySet","id","val","JSON","stringify","json","getItem","parse","error","pushState","sessionId","replaceState","go","n","getCurrentIndex","_id","PREFIX","createSessionId","process","env","NODE_ENV","toString","substr","Math","random","pathname","search","hash"],"mappings":"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","sourcesContent":["// @flow\n/* eslint-env browser */\nimport { toEntries } from '../../utils'\n\n// API:\n\n// Below is the facade around both `sessionStorage` and our \"history as storage\" fallback.\n//\n// - `saveHistory` is  called every time the history entries or index changes\n// - `restoreHistory` is called on startup obviously\n\n// Essentially the idea is that if there is no `sessionStorage`, we maintain the entire\n// storage object on EACH AND EVERY history entry's `state`. I.e. `history.state` on\n// every page will have the `index` and `entries` array. That way when browsers disable\n// cookies/sessionStorage, we can still grab the data we need off off of history state :)\n//\n// It's a bit crazy, but it works very well, and there's plenty of space allowed for storing\n// things there to get a lot of mileage out of it. We store the minimum amount of data necessary.\n//\n// Firefox has the lowest limit of 640kb PER ENTRY. IE has 1mb and chrome has at least 10mb:\n// https://stackoverflow.com/questions/6460377/html5-history-api-what-is-the-max-size-the-state-object-can-be\n\nexport const saveHistory = ({ entries }) => {\n  entries = entries.map((e) => [e.location.url, e.state, e.location.key]) // one entry has the url, a state object, and a 6 digit key\n  set({ entries })\n}\n\nexport const restoreHistory = (api) => {\n  let history = get()\n  if (!history) {\n    history = initializeHistory()\n  } else {\n    history.index = getHistoryState().index\n  }\n  return format(history, api)\n}\n\nexport const clear = () => {\n  window.sessionStorage.setItem(key(), '')\n  historySet({ index: 0, id: key() })\n}\n\nconst set = (val) => window.sessionStorage.setItem(key(), JSON.stringify(val))\n\nexport const get = () => {\n  try {\n    const json = window.sessionStorage.getItem(key())\n    return JSON.parse(json)\n  } catch (error) {\n    return null\n  }\n}\n\n// HISTORY FACADE:\n\nexport const pushState = (url: string) =>\n  window.history.pushState(\n    { id: sessionId(), index: getHistoryState().index + 1 },\n    null,\n    url,\n  ) // insure every entry has the sessionId (called by `BrowserHistory`)\n\nexport const replaceState = (url: string) =>\n  window.history.replaceState(\n    { id: sessionId(), index: getHistoryState().index },\n    null,\n    url,\n  ) // QA: won't the fallback overwrite the `id`? Yes, but the fallback doesn't use the `id` :)\n\nexport const go = (n) => window.history.go(n)\n\nexport const getCurrentIndex = () => getHistoryState().index\n\nconst historySet = (history) => window.history.replaceState(history, null) // set on current entry\n\n// SESSION STORAGE FACADE:\n\n// We use `history.state.id` to pick which \"session\" from `sessionStorage` to use in\n// the case that multiple instances of the app exist in the browser history stack of\n// the same tab (e.g. if you navigate away from the app and then back again)\nlet _id\n\nconst PREFIX = '@@rudy/'\n\nconst sessionId = () => (_id = _id || createSessionId())\n\nconst key = () => PREFIX + sessionId()\n\nconst createSessionId = () => {\n  const state = getHistoryState()\n\n  if (!state.id) {\n    if (process.env.NODE_ENV === 'test') {\n      state.id = '123456789'.toString(36).substr(2, 6)\n    } else {\n      state.id = Math.random()\n        .toString(36)\n        .substr(2, 6)\n    }\n    state.index = 0\n    historySet(state)\n  }\n\n  return state.id\n}\n\n// HELPERS:\n\nconst initializeHistory = () => {\n  const { pathname, search, hash } = window.location\n  const url = pathname + search + hash\n  return { n: 1, index: 0, entries: [url] } // default history on first load\n}\n\nconst format = (history, api) => {\n  const { entries, index } = history\n  return toEntries(api, entries, index)\n}\n\n// IE11 sometimes throws when accessing `history.state`:\n//\n// - https://github.com/ReactTraining/history/pull/289\n// - https://github.com/ReactTraining/history/pull/230#issuecomment-193555362\n//\n// The issue occurs:\n// A) when you refresh a page that is the only entry and never had state set on it,\n// which means it wouldn't have any state to remember in the first place\n//\n// B) in IE11 on load in iframes, which also won't need to remember state, as iframes\n// usually aren't for navigating to other sites (and back). This may just be issue A)\nconst getHistoryState = () => {\n  try {\n    return window.history.state || {}\n  } catch (e) {\n    return {}\n  }\n}\n"],"file":"sessionStorage.js"}