{"version":3,"sources":["../../../src/history/utils/sessionStorage.js"],"names":["toEntries","supportsSessionStorage","saveHistory","entries","map","e","location","url","state","key","set","restoreHistory","api","history","get","initializeHistory","index","getHistoryState","format","fallbackSessionState","clear","window","sessionStorage","setItem","historySet","id","val","JSON","stringify","json","getItem","parse","pushState","href","Promise","sessionId","resolve","replaceState","go","n","getCurrentIndex","_id","PREFIX","createSessionId","process","env","NODE_ENV","toString","substr","Math","random","pathname","search","hash"],"mappings":"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","sourcesContent":["// @flow\n/* eslint-env browser */\nimport { toEntries } from '../../utils'\nimport { supportsSessionStorage } from '@respond-framework/utils'\n\n// API:\n\n// Below is the facade around both `sessionStorage` and our \"history as storage\" fallback.\n//\n// - `saveHistory` is  called every time the history entries or index changes\n// - `restoreHistory` is called on startup obviously\n\n// If there is no `sessionStorage` (which happens e.g. in incognito mode in iOS safari), we\n// have a fallback which is simply module state (which is reset on page reload). In this case,\n// we don't use window.pushState and therefore ensure that the length of the SPA history is 1.\n// This is because we can't store our mirrored history stack across page reloads, external\n// navigation, etc, which is needed to correctly intercept SPA history actions.\n\nexport const saveHistory = ({ entries }) => {\n  entries = entries.map((e) => [e.location.url, e.state, e.location.key]) // one entry has the url, a state object, and a 6 digit key\n  set({ entries })\n}\n\nexport const restoreHistory = (api) => {\n  let history = get()\n  if (!history) {\n    history = initializeHistory()\n  } else {\n    history.index = getHistoryState().index\n  }\n  return format(history, api)\n}\n\nlet fallbackSessionState = ''\n\nexport const clear = () => {\n  if (supportsSessionStorage()) {\n    window.sessionStorage.setItem(key(), '')\n  } else {\n    fallbackSessionState = ''\n  }\n  historySet({ index: 0, id: key() })\n}\n\nconst set = (val) => {\n  if (supportsSessionStorage()) {\n    window.sessionStorage.setItem(key(), JSON.stringify(val))\n  } else {\n    fallbackSessionState = JSON.stringify(val)\n  }\n}\n\nexport const get = () => {\n  let json\n  if (supportsSessionStorage()) {\n    json = window.sessionStorage.getItem(key())\n  } else {\n    json = fallbackSessionState\n  }\n  try {\n    return JSON.parse(json)\n  } catch {\n    return null\n  }\n}\n\n// HISTORY FACADE:\n\nexport const pushState = (url: string) => {\n  if (!supportsSessionStorage()) {\n    // If session storage is no supported, do not create a history\n    // with multiple entries\n    window.location.href = url\n    // Block until the page reloads\n    return new Promise(() => {})\n  }\n  window.history.pushState(\n    { id: sessionId(), index: getHistoryState().index + 1 },\n    null,\n    url,\n  ) // insure every entry has the sessionId (called by `BrowserHistory`)\n  return Promise.resolve()\n}\n\nexport const replaceState = (url: string) =>\n  window.history.replaceState(\n    { id: sessionId(), index: getHistoryState().index },\n    null,\n    url,\n  ) // QA: won't the fallback overwrite the `id`? Yes, but the fallback doesn't use the `id` :)\n\nexport const go = (n) => window.history.go(n)\n\nexport const getCurrentIndex = () => getHistoryState().index\n\nconst historySet = (history) => window.history.replaceState(history, null) // set on current entry\n\n// SESSION STORAGE FACADE:\n\n// We use `history.state.id` to pick which \"session\" from `sessionStorage` to use in\n// the case that multiple instances of the app exist in the browser history stack of\n// the same tab (e.g. if you navigate away from the app and then back again)\nlet _id\n\nconst PREFIX = '@@rudy/'\n\nconst sessionId = () => (_id = _id || createSessionId())\n\nconst key = () => PREFIX + sessionId()\n\nconst createSessionId = () => {\n  const state = getHistoryState()\n\n  if (!state.id) {\n    if (process.env.NODE_ENV === 'test') {\n      state.id = '123456789'.toString(36).substr(2, 6)\n    } else {\n      state.id = Math.random()\n        .toString(36)\n        .substr(2, 6)\n    }\n    state.index = 0\n    historySet(state)\n  }\n\n  return state.id\n}\n\n// HELPERS:\n\nconst initializeHistory = () => {\n  const { pathname, search, hash } = window.location\n  const url = pathname + search + hash\n  return { n: 1, index: 0, entries: [url] } // default history on first load\n}\n\nconst format = (history, api) => {\n  const { entries, index } = history\n  return toEntries(api, entries, index)\n}\n\n// IE11 sometimes throws when accessing `history.state`:\n//\n// - https://github.com/ReactTraining/history/pull/289\n// - https://github.com/ReactTraining/history/pull/230#issuecomment-193555362\n//\n// The issue occurs:\n// A) when you refresh a page that is the only entry and never had state set on it,\n// which means it wouldn't have any state to remember in the first place\n//\n// B) in IE11 on load in iframes, which also won't need to remember state, as iframes\n// usually aren't for navigating to other sites (and back). This may just be issue A)\nconst getHistoryState = () => {\n  try {\n    return window.history.state || {}\n  } catch (e) {\n    return {}\n  }\n}\n"],"file":"sessionStorage.js"}