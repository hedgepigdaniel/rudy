{"version":3,"sources":["../../src/utils/compileUrl.js"],"names":["toPathCache","path","params","query","hash","route","opts","search","stringify","Error","undefined","toPath","p","s","h","stringifyQuery","process","env","NODE_ENV","length","console","error"],"mappings":";;;;;;;AACA;;AACA;;AAIA,IAAMA,WAAW,GAAG,EAApB;;eAEe,kBACbC,IADa,EAOV;AAAA,MALHC,MAKG,uEALc,EAKd;AAAA,MAJHC,KAIG;AAAA,MAHHC,IAGG;AAAA,MAFHC,KAEG,uEAFY,EAEZ;AAAA,MADHC,IACG;AACH,MAAMC,MAAM,GAAGJ,KAAK,GAAGK,SAAS,CAACL,KAAD,EAAQE,KAAR,EAAeC,IAAf,CAAZ,GAAmC,EAAvD;;AAEA,MAAID,KAAK,CAACF,KAAN,IAAe,CAAC,0BAAWI,MAAX,EAAmBF,KAAK,CAACF,KAAzB,EAAgCE,KAAhC,EAAuCC,IAAvC,CAApB,EAAkE;AAChE,UAAM,IAAIG,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAED,MACEJ,KAAK,CAACD,IAAN,KAAeM,SAAf,IACA,yBAAUN,IAAV,EAAgBC,KAAK,CAACD,IAAtB,EAA4BC,KAA5B,EAAmCC,IAAnC,KAA4C,IAF9C,EAGE;AACA,UAAM,IAAIG,KAAJ,CAAU,2BAAV,CAAN;AACD;;AAEDT,EAAAA,WAAW,CAACC,IAAD,CAAX,GAAoBD,WAAW,CAACC,IAAD,CAAX,IAAqB,2BAAQA,IAAR,CAAzC;AACA,MAAMU,MAAM,GAAGX,WAAW,CAACC,IAAD,CAA1B;AAEA,MAAMW,CAAC,GAAGD,MAAM,CAACT,MAAD,CAAhB;AACA,MAAMW,CAAC,GAAGN,MAAM,cAAOA,MAAP,IAAkB,EAAlC;AACA,MAAMO,CAAC,GAAGV,IAAI,cAAOA,IAAP,IAAgB,EAA9B;AAEA,SAAOQ,CAAC,GAAGC,CAAJ,GAAQC,CAAf;AACD,C;;;;AAED,IAAMN,SAAS,GAAG,SAAZA,SAAY,CAACL,KAAD,EAAQE,KAAR,EAAsBC,IAAtB,EAAwC;AACxD,MAAMC,MAAM,GAAG,CAACF,KAAK,CAACU,cAAN,IAAwBT,IAAI,CAACS,cAA9B,EAA8CZ,KAA9C,CAAf;;AAEA,MAAIa,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,aAAzB,IAA0CX,MAAM,CAACY,MAAP,GAAgB,IAA9D,EAAoE;AAClE;AACA;AACAC,IAAAA,OAAO,CAACC,KAAR,qCAC+Bd,MAAM,CAACY,MADtC;AAGD;;AAED,SAAOZ,MAAP;AACD,CAZD","sourcesContent":["// @flow\nimport { compile } from 'path-to-regexp'\nimport { matchQuery, matchHash } from './matchUrl'\n\nimport type { Route, Options } from '../flow-types'\n\nconst toPathCache = {}\n\nexport default (\n  path: string,\n  params: Object = {},\n  query: ?Object,\n  hash: ?string,\n  route: Route = {},\n  opts: Options,\n) => {\n  const search = query ? stringify(query, route, opts) : ''\n\n  if (route.query && !matchQuery(search, route.query, route, opts)) {\n    throw new Error('[rudy] invalid query object')\n  }\n\n  if (\n    route.hash !== undefined &&\n    matchHash(hash, route.hash, route, opts) == null\n  ) {\n    throw new Error('[rudy] invalid hash value')\n  }\n\n  toPathCache[path] = toPathCache[path] || compile(path)\n  const toPath = toPathCache[path]\n\n  const p = toPath(params)\n  const s = search ? `?${search}` : ''\n  const h = hash ? `#${hash}` : ''\n\n  return p + s + h\n}\n\nconst stringify = (query, route: Route, opts: Options) => {\n  const search = (route.stringifyQuery || opts.stringifyQuery)(query)\n\n  if (process.env.NODE_ENV === 'development' && search.length > 2000) {\n    // https://stackoverflow.com/questions/812925/what-is-the-maximum-possible-length-of-a-query-string\n    // eslint-disable-next-line no-console\n    console.error(\n      `[rudy] query is too long: ${search.length} chars (max: 2000)`,\n    )\n  }\n\n  return search\n}\n"],"file":"compileUrl.js"}