{"version":3,"sources":["../src/index.ts"],"names":["RudyScrollRestorer","api","options","entry","scrollBehaviorKey","location","key","JSON","stringify","value","window","sessionStorage","setItem","makeStorageKey","savedItem","getItem","parse","getLocation","entries","index","request","next","lastRequest","action","prev","Object","keys","transitionHooks","forEach","hookIndex","behavior","updateScroll","ScrollBehavior","addTransitionHook","hook","nextHookIndex","stateStorage","save","saveScrollPosition","read","readScrollPosition","getCurrentLocation","shouldUpdateScroll","undefined"],"mappings":";;;;;;;;;;;;;AACA;;;;;;;;;;IAyBaA,kB,GAsDX,4BAAYC,GAAZ,EAA0E;AAAA;;AAAA,MAA5CC,OAA4C,uEAAJ,EAAI;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA,2CAxCX,EAwCW;;AAAA,yCAtClD,CAsCkD;;AAAA,0CApCjD,UACvBC,KADuB,EAEvBC,iBAFuB;AAAA,2CAKrBD,KAAK,aAAMA,KAAK,CAACE,QAAN,CAAeC,GAArB,WALgB,SAMpBC,IAAI,CAACC,SAAL,CAAeJ,iBAAf,CANoB;AAAA,GAoCiD;;AAAA,8CA5B7C,UAC3BD,KAD2B,EAE3BG,GAF2B,EAG3BG,KAH2B,EAIlB;AACTC,IAAAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,CACE,KAAI,CAACC,cAAL,CAAoBV,KAApB,EAA2BG,GAA3B,CADF,EAEEC,IAAI,CAACC,SAAL,CAAeC,KAAf,CAFF;AAID,GAmByE;;AAAA,8CAjBrD,UACnBN,KADmB,EAEnBG,GAFmB,EAGO;AAC1B,QAAMQ,SAAS,GAAGJ,MAAM,CAACC,cAAP,CAAsBI,OAAtB,CAChB,KAAI,CAACF,cAAL,CAAoBV,KAApB,EAA2BG,GAA3B,CADgB,CAAlB;;AAGA,QAAIQ,SAAS,KAAK,IAAlB,EAAwB;AACtB,aAAO,IAAP;AACD;;AACD,QAAI;AACF,aAAOP,IAAI,CAACS,KAAL,CAAWF,SAAX,CAAP;AACD,KAFD,CAEE,gBAAM;AACN,aAAO,IAAP;AACD;AACF,GAEyE;;AAAA,8CA8B7C,YAA6B;AACxD,QAAMT,QAAQ,GAAG,KAAI,CAACJ,GAAL,CAASgB,WAAT,EAAjB;;AACA,WAAOZ,QAAQ,CAACa,OAAT,CAAiBb,QAAQ,CAACc,KAA1B,CAAP;AACD,GAjCyE;;AAAA,sCAmCzC,YAAM;AACrC,WAAO,UAACC,OAAD,EAAUC,IAAV,EAAmB;AACxB,MAAA,KAAI,CAACC,WAAL,GAAmBF,OAAnB;AADwB,UAEhBG,MAFgB,GAELH,OAFK,CAEhBG,MAFgB;;AAGxB,UAAI,EAAE,cAAcA,MAAd,IAAwBA,MAAM,CAAClB,QAAP,CAAgBmB,IAA1C,CAAJ,EAAqD;AACnD;AACA,eAAOH,IAAI,EAAX;AACD;;AACDI,MAAAA,MAAM,CAACC,IAAP,CAAY,KAAI,CAACC,eAAjB,EAAkCC,OAAlC,CAA0C,UAACC,SAAD,EAAe;AACvD,QAAA,KAAI,CAACF,eAAL,CAAqBE,SAArB;AACD,OAFD;AAGA,aAAOR,IAAI,EAAX;AACD,KAXD;AAYD,GAhDyE;;AAAA,yCAkDtC,YAAM;AACxC,WAAO,UAACD,OAAD,EAAUC,IAAV,EAAmB;AACxB,MAAA,KAAI,CAACS,QAAL,CAAcC,YAAd,CAA2BX,OAA3B;;AACA,aAAOC,IAAI,EAAX;AACD,KAHD;AAID,GAvDyE;;AAAA,wCAyD3D,YAAY;AACzB,IAAA,KAAI,CAACS,QAAL,CAAcC,YAAd,CAA2B,KAAI,CAACT,WAAhC;AACD,GA3DyE;;AACxE,OAAKrB,GAAL,GAAWA,GAAX;AACA,OAAKC,OAAL,GAAeA,OAAf;AACA,OAAK4B,QAAL,GAAgB,IAAIE,uBAAJ,CAId;AACAC,IAAAA,iBAAiB,EAAE,2BAACC,IAAD,EAA0B;AAC3C,UAAML,SAAS,GAAG,KAAI,CAACM,aAAvB;AACA,MAAA,KAAI,CAACA,aAAL,IAAsB,CAAtB;AACA,MAAA,KAAI,CAACR,eAAL,CAAqBE,SAArB,IAAkCK,IAAlC;AACA,aAAO,YAAM;AACX,eAAO,KAAI,CAACP,eAAL,CAAqBE,SAArB,CAAP;AACD,OAFD;AAGD,KARD;AASAO,IAAAA,YAAY,EAAE;AACZC,MAAAA,IAAI,EAAE,KAAKC,kBADC;AAEZC,MAAAA,IAAI,EAAE,KAAKC;AAFC,KATd;AAaAC,IAAAA,kBAAkB,EAAE;AAAA,aAAM,KAAI,CAACA,kBAAL,EAAN;AAAA,KAbpB;AAcAC,IAAAA,kBAAkB,EAAE,4BAACtB,OAAD,EAAa;AAC/B,UAAI,CAAC,KAAI,CAAClB,OAAL,CAAawC,kBAAlB,EAAsC;AACpC,eAAO,IAAP,CADoC,CACxB;AACb;;AACD,aAAO,KAAI,CAACxC,OAAL,CAAawC,kBAAb,CAAgCtB,OAAhC,EAAyCuB,SAAzC,CAAP;AACD;AAnBD,GAJc,CAAhB;AAyBD,C;;;;eAkCY,kBACbzC,OADa;AAAA,SAEqB,UAACD,GAAD;AAAA,WAClC,IAAID,kBAAJ,CAAuBC,GAAvB,EAA4BC,OAA5B,CADkC;AAAA,GAFrB;AAAA,C","sourcesContent":["/* eslint-env browser */\nimport ScrollBehavior, {\n  TransitionHook,\n  ScrollPosition,\n  ShouldUpdateScroll as BaseShouldUpdateScroll,\n} from 'scroll-behavior'\nimport {\n  Api,\n  Middleware,\n  LocationEntry,\n  FluxStandardRoutingAction,\n  Request,\n  ScrollRestorer,\n  ScrollRestorerCreator,\n} from '@respond-framework/types'\n\nexport { ScrollPosition } from 'scroll-behavior'\n\nexport type ShouldUpdateScroll<\n  Action extends FluxStandardRoutingAction\n> = BaseShouldUpdateScroll<Request<Action>, undefined>\n\nexport type RestoreScrollOptions<Action extends FluxStandardRoutingAction> = {\n  shouldUpdateScroll?: ShouldUpdateScroll<Action>\n}\n\nexport class RudyScrollRestorer<Action extends FluxStandardRoutingAction>\n  implements ScrollRestorer<Action> {\n  private options: RestoreScrollOptions<Action>\n\n  private behavior: ScrollBehavior<\n    LocationEntry<Action>,\n    Request<Action>,\n    never\n  >\n\n  private lastRequest?: Request<Action>\n\n  private api: Api<Action>\n\n  private transitionHooks: { [index: string]: TransitionHook } = {}\n\n  private nextHookIndex = 0\n\n  private makeStorageKey = (\n    entry: LocationEntry<Action> | null,\n    scrollBehaviorKey: string | null,\n  ): string =>\n    `@@rudy-restore-scroll/${\n      entry ? `${entry.location.key}/` : ``\n    }${JSON.stringify(scrollBehaviorKey)}`\n\n  private saveScrollPosition = (\n    entry: LocationEntry<Action>,\n    key: string | null,\n    value: ScrollPosition,\n  ): void => {\n    window.sessionStorage.setItem(\n      this.makeStorageKey(entry, key),\n      JSON.stringify(value),\n    )\n  }\n\n  readScrollPosition = (\n    entry: LocationEntry<Action>,\n    key: string | null,\n  ): ScrollPosition | null => {\n    const savedItem = window.sessionStorage.getItem(\n      this.makeStorageKey(entry, key),\n    )\n    if (savedItem === null) {\n      return null\n    }\n    try {\n      return JSON.parse(savedItem)\n    } catch {\n      return null\n    }\n  }\n\n  constructor(api: Api<Action>, options: RestoreScrollOptions<Action> = {}) {\n    this.api = api\n    this.options = options\n    this.behavior = new ScrollBehavior<\n      LocationEntry<Action>,\n      Request<Action>,\n      never\n    >({\n      addTransitionHook: (hook: TransitionHook) => {\n        const hookIndex = this.nextHookIndex\n        this.nextHookIndex += 1\n        this.transitionHooks[hookIndex] = hook\n        return () => {\n          delete this.transitionHooks[hookIndex]\n        }\n      },\n      stateStorage: {\n        save: this.saveScrollPosition,\n        read: this.readScrollPosition,\n      },\n      getCurrentLocation: () => this.getCurrentLocation(),\n      shouldUpdateScroll: (request) => {\n        if (!this.options.shouldUpdateScroll) {\n          return true // default behaviour\n        }\n        return this.options.shouldUpdateScroll(request, undefined)\n      },\n    })\n  }\n\n  private getCurrentLocation = (): LocationEntry<Action> => {\n    const location = this.api.getLocation()\n    return location.entries[location.index]\n  }\n\n  saveScroll: Middleware<Action> = () => {\n    return (request, next) => {\n      this.lastRequest = request\n      const { action } = request\n      if (!('location' in action && action.location.prev)) {\n        // If there is no previous location, there is no position to save\n        return next()\n      }\n      Object.keys(this.transitionHooks).forEach((hookIndex) => {\n        this.transitionHooks[hookIndex]()\n      })\n      return next()\n    }\n  }\n\n  restoreScroll: Middleware<Action> = () => {\n    return (request, next) => {\n      this.behavior.updateScroll(request)\n      return next()\n    }\n  }\n\n  updateScroll = (): void => {\n    this.behavior.updateScroll(this.lastRequest)\n  }\n}\n\nexport default <Action extends FluxStandardRoutingAction>(\n  options?: RestoreScrollOptions<Action>,\n): ScrollRestorerCreator<Action> => (api) =>\n  new RudyScrollRestorer(api, options)\n"],"file":"index.js"}