{"version":3,"sources":["../../src/history/BrowserHistory.js"],"names":["BrowserHistory","options","restore","restoreHistory","save","saveHistory","_setupPopHandling","dispatch","getLocation","_addPopListener","unlisten","_removePopListener","handlePop","_popForced","window","location","pathname","search","hash","url","n","pendingPop","index","_forceGo","reverted","revertPop","currentPop","jump","onPopState","e","onHashChange","Promise","resolve","action","awaitUrl","_awaitUrl","then","kind","currUrl","oldUrl","isPop","_replace","entries","changedAction","oldFirstUrl","reverseN","lastIndex","length","reverseDeltaToIndex","indexUrl","slice","forEach","actOrUrl","name","ready","tryChange","History","tries","maxTries","queue","complete","rapidChangeWorkaround","push","setTimeout","process","env","NODE_ENV","Error","shift","again","com"],"mappings":"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","sourcesContent":["// @flow\n/* eslint-env browser */\nimport History from './History'\nimport { locationToUrl } from '../utils'\nimport {\n  addPopListener,\n  removePopListener,\n  isExtraneousPopEvent,\n  restoreHistory,\n  saveHistory,\n  pushState,\n  replaceState,\n  go,\n  getCurrentIndex,\n} from './utils'\nimport type { Action, Dispatch } from '../flow-types'\n\n// 1) HISTORY RESTORATION:\n// * FROM SESSION_STORAGE\n\n// The `id` below is very important, as it's used to identify unique `sessionStorage` sessions lol.\n\n// Essentially, you can have multiple tabs open, or even in the same tab multiple sessions if you\n// enter another URL at the same site manually. Each need their history entries independently tracked.\n\n// So we:\n// - create an `id` for each when first encountered\n// - store it in `this.state.id`\n// - and prefix their `sessionStorage` key with it to uniquely identify the different histories :)\n\n// - then we restore the history using the id\n// - and for all subsequent history saving, we save to the correct storage with that `id`\n\n// 2) POP HANDLING -- THE MOST IMPORTANT THING HERE:\n\n// A) REVERT POP: `forceGo(currentIndex - index)`\n// The first executed `forceGo` automatically undos the pop event, putting the browser history\n// back to where it was. Since the `jump` function takes relative numbers, we must calculate\n// that number by subtracting the current index from the next index\n\n// B) COMMIT POP: `forceGo(index - currentIndex)`\n// similarly the `commit` function performed in client code performs the reverse operation\n\n// EXAMPLE:\n// User presses back from index 5 to 4\n// revert: 5 - 4 === jump(1)\n// commit: 4 - 5 === jump(-1)\n// :)\n\n// WHY?\n// so client code can control when the URL actually changes, and possibly deny it\n\nexport default class BrowserHistory extends History {\n  _restore() {\n    this.options.restore = this.options.restore || restoreHistory\n    this.options.save = this.options.save || saveHistory\n\n    this._setupPopHandling()\n\n    return this.options.restore(this)\n  }\n\n  listen(dispatch: Dispatch, getLocation: Function) {\n    if (!this.dispatch) {\n      // we don't allow/need multiple listeners currently\n      super.listen(dispatch, getLocation)\n      this._addPopListener()\n    }\n\n    return () => this.unlisten()\n  }\n\n  unlisten() {\n    this._removePopListener()\n    super.unlisten()\n  }\n\n  _setupPopHandling() {\n    const handlePop = () => {\n      if (this._popForced) return (this._popForced = false)\n\n      const { pathname, search, hash } = window.location\n      const url = pathname + search + hash\n\n      let n\n\n      if (!this.pendingPop) {\n        n = getCurrentIndex() - this.index\n        this.pendingPop = n\n      } else if (url === this.url) {\n        n = this.pendingPop * -1 // switch directions\n        return this._forceGo(n * -1)\n      } else {\n        n = this.pendingPop\n        return this._forceGo(n * -1)\n      }\n\n      let reverted = false\n\n      const revertPop = () => {\n        if (!reverted) this._forceGo(n * -1)\n        reverted = true\n      }\n\n      // revertPop will be called if route change blocked by `core/compose.js` or used as\n      // a flag by `this._jump` below to do nothing in the browser, since the user already\n      // did it via browser back/next buttons\n      this.currentPop = this.jump(n, false, n, true, revertPop) // `currentPop` used only by tests to await browser-initiated pops\n    }\n\n    const onPopState = (e) => !isExtraneousPopEvent(e) && handlePop() // ignore extraneous popstate events in WebKit\n    const onHashChange = handlePop\n\n    this._addPopListener = () => addPopListener(onPopState, onHashChange)\n    this._removePopListener = () => removePopListener(onPopState, onHashChange)\n  }\n\n  _forceGo(n: number): Promise<void> {\n    this._popForced = true\n    go(n) // revert\n    return Promise.resolve()\n  }\n\n  _push(action: Action, awaitUrl: string): Promise<any> {\n    const { url } = action.location\n\n    return this._awaitUrl(awaitUrl, '_push').then(() => pushState(url))\n  }\n\n  _replace(action: Action, awaitUrl: string, n?: number): Promise<any> {\n    const { url } = action.location\n\n    if (n) {\n      this._forceGo(n)\n\n      return this._awaitUrl(awaitUrl, '_replaceBackNext').then(() =>\n        replaceState(url),\n      )\n    }\n\n    if (this.location.kind === 'load') {\n      awaitUrl = locationToUrl(window.location) // special case: redirects on load have no previous URL\n    }\n\n    return this._awaitUrl(awaitUrl, '_replace').then(() => replaceState(url))\n  }\n\n  _jump(\n    action: Action,\n    currUrl: string,\n    oldUrl: string,\n    n: number,\n    isPop: boolean,\n  ): void | Promise<any> {\n    if (!n) {\n      // possibly the user mathematically calculated a jump of `0`\n      return this._replace(action, currUrl)\n    }\n\n    if (isPop) return // pop already handled by browser back/next buttons and real history state is already up to date\n\n    return this._awaitUrl(currUrl, 'jump prev')\n      .then(() => this._forceGo(n))\n      .then(() => this._awaitUrl(oldUrl, 'jump loc'))\n      .then(() => this._replace(action, oldUrl))\n  }\n\n  _set(action: Action, oldUrl: string, n: number): Promise<any> {\n    if (!n) {\n      return this._replace(action, oldUrl)\n    }\n\n    const { index, entries } = action.location\n    const changedAction = entries[index + n]\n\n    return this._awaitUrl(action, '_setN start')\n      .then(() => this._forceGo(n))\n      .then(() => this._awaitUrl(oldUrl, '_setN before replace'))\n      .then(() => this._replace(changedAction, oldUrl))\n      .then(() => this._forceGo(-n))\n      .then(() => this._awaitUrl(action, 'setN return'))\n  }\n\n  _reset(\n    action: Action,\n    oldUrl: string,\n    oldFirstUrl: string,\n    reverseN: number,\n  ): Promise<any> {\n    const { index, entries } = action.location\n    const lastIndex = entries.length - 1\n    const reverseDeltaToIndex = index - lastIndex\n    const indexUrl = entries[index].location.url\n\n    return this._awaitUrl(oldUrl, 'reset oldUrl')\n      .then(() => this._forceGo(reverseN))\n      .then(() => this._awaitUrl(oldFirstUrl, 'reset oldFirstUrl'))\n      .then(() => {\n        replaceState(entries[0].location.url) // we always insure resets have at least 2 entries, and the first can only operate via `replaceState`\n        entries.slice(1).forEach((e) => pushState(e.location.url)) // we have to push at least one entry to erase the old entries in the real browser history\n\n        if (reverseDeltaToIndex) {\n          return this._forceGo(reverseDeltaToIndex).then(() =>\n            this._awaitUrl(indexUrl, 'resetIndex _forceGo'),\n          )\n        }\n      })\n  }\n\n  _awaitUrl(actOrUrl: string | Object, name: string): Promise<any> {\n    return new Promise((resolve) => {\n      const url =\n        typeof actOrUrl === 'string' ? actOrUrl : actOrUrl.location.url\n      const ready = () => {\n        return url === locationToUrl(window.location)\n      }\n      return tryChange(ready, resolve, name, this) // TODO: is the this supposed to be there, its one extra param over\n    })\n  }\n}\n\n// CHROME WORKAROUND:\n// chrome doesn't like rapid back to back history changes, so we test the first\n// change happened first, before executing the next\n\nlet tries = 0\nconst maxTries = 10\nconst queue = []\n\nconst tryChange = (ready, complete, name) => {\n  if (tries === 0) rapidChangeWorkaround(ready, complete, name)\n  else queue.push([ready, complete, name])\n}\n\nconst rapidChangeWorkaround = (ready, complete, name) => {\n  tries++\n\n  if (!ready() && tries < maxTries) {\n    setTimeout(() => rapidChangeWorkaround(ready, complete, name), 9)\n  } else {\n    if (process.env.NODE_ENV === 'test' && !ready()) {\n      throw new Error(\n        'BrowserHistory.rapidChangeWorkAround failed to be \"ready\"',\n      )\n    }\n\n    complete()\n    tries = 0\n\n    const [again, com, name] = queue.shift() || [] // try another if queue is full\n\n    if (again) {\n      rapidChangeWorkaround(again, com, name)\n    }\n  }\n}\n"],"file":"BrowserHistory.js"}