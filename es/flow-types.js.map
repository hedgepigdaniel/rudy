{"version":3,"sources":["../src/flow-types.js"],"names":["CALL_HISTORY"],"mappings":"AAEA,SAASA,YAAT,QAA6B,SAA7B","sourcesContent":["// @flow\nimport type { Dispatch as ReduxDispatch, Store as ReduxStore } from 'redux'\nimport { CALL_HISTORY } from './types'\n\nexport type Dispatch = ReduxDispatch<*>\nexport type GetState = () => Object\n\nexport type BeforeLeave = (\n  state: Object,\n  action: Object,\n  bag: Bag,\n) => any | Promise<any>\n\nexport type Bag = {\n  action: ReceivedAction | Action | Location,\n  extra: any,\n}\n\nexport type StandardCallback = (\n  dispatch: Dispatch,\n  getState: GetState,\n  bag: Bag,\n) => ?any | Promise<any>\n\nexport type FromPath = (\n  val: void | string | Array<string>,\n  { name: string, repeat: boolean, optional: boolean },\n  route: Route,\n  opts: Options,\n) => any\n\nexport type ToPath = (\n  val: any,\n  { name: string, repeat: boolean, optional: boolean },\n  route: Route,\n  opts: Options,\n) => void | string | Array<string>\n\nexport type ObjectDefault = Object | ((?Object, Route, Options) => ?Object)\nexport type StringDefault = string | ((?string, Route, Options) => string)\n\nexport type Route = {\n  path?: string,\n  toPath?: ToPath,\n  type?: string,\n  scene?: string,\n  navKey?: string,\n  redirect?: Function,\n  toSearch?: Function,\n  defaultParams?: ObjectDefault,\n  defaultQuery?: ObjectDefault,\n  defaultState?: ObjectDefault,\n  defaultHash?: StringDefault,\n  thunk?: StandardCallback,\n  beforeLeave?: BeforeLeave,\n  onFail?: StandardCallback,\n  capitalizedWords?: boolean,\n  convertNumbers?: boolean,\n  onEnter?: StandardCallback,\n  onLeave?: StandardCallback,\n  onComplete?: StandardCallback,\n  beforeEnter?: StandardCallback,\n  defaultHash?: Function | string,\n  parseSearch?: (?string) => Object,\n  stringifyQuery?: (?Object) => string,\n  fromSearch?: Function,\n  fromPath?: FromPath,\n  toHash?: (hash: string, route: Route, opts: Options) => string,\n}\n\nexport type RouteInput = Function | Route\n\nexport type RoutesInput = {\n  [key: string]: RouteInput,\n}\n\nexport type Routes = {\n  [key: string]: Route,\n}\n\nexport type Router = {\n  getStateForActionOriginal: (action: Object, state: ?Object) => ?Object,\n  getStateForAction: (action: Object, state: ?Object) => ?Object,\n  getPathAndParamsForState: (\n    state: Object,\n  ) => { path: ?string, params: ?Object },\n  getActionForPathAndParams: (path: string) => ?Object,\n}\n\nexport type Navigator = {\n  router: Router,\n}\n\nexport type Navigators = {\n  [key: string]: Navigator,\n}\n\nexport type RouteNames = Array<string>\n\nexport type SelectLocationState = (state: Object) => LocationState\nexport type SelectTitleState = (state: Object) => string\n\nexport type QuerySerializer = {\n  stringify: (params: Object) => string,\n  parse: (queryString: string) => Object,\n}\n\nexport type ActionToNavigation = (\n  navigators: Navigators,\n  action: Object,\n  navigationAction: ?NavigationAction,\n  route: ?Route,\n) => Object\n\nexport type NavigationToAction = (\n  navigators: Navigators,\n  store: Store,\n  routesMap: Routes,\n  action: Object,\n) => {\n  action: Object,\n  navigationAction: ?NavigationAction,\n}\n\n// TODO: Question: Is can this be split up to sub-types at some point.\nexport type Options = {\n  extra?: any,\n  toPath?: ?any,\n  toSearch?: any,\n  capitalizedWords?: boolean,\n  convertNumbers?: boolean,\n  basename?: string,\n  basenames?: Array<string>,\n  scrollTop?: boolean,\n  notFoundPath?: string,\n  defaultState?: ObjectDefault,\n  defaultQuery?: ObjectDefault,\n  defaultParams?: ObjectDefault,\n  defaultHash?: StringDefault,\n  thunk?: StandardCallback,\n  beforeLeave?: BeforeLeave,\n  onFail?: StandardCallback,\n  onEnter?: StandardCallback,\n  onLeave?: StandardCallback,\n  onError?: StandardCallback,\n  onComplete?: StandardCallback,\n  onBackNext?: StandardCallback,\n  beforeEnter?: StandardCallback,\n  defaultHash?: Function | string,\n  title?: string | SelectTitleState,\n  querySerializer?: QuerySerializer,\n  parseSearch?: (?string) => Object,\n  stringifyQuery?: (?Object) => string,\n  location?: string | SelectLocationState,\n  initialEntries?: string | Array<string>,\n  restoreScroll?: (History) => ScrollBehavior,\n  createHistory?: (options?: Object) => History,\n  toHash?: (hash: string, route: Route, opts: Options) => string,\n  shouldTransition?: StandardCallback,\n  createRequest?: StandardCallback,\n  compose?: StandardCallback,\n  fromPath?: FromPath,\n  navigators?: {\n    navigators: Navigators,\n    patchNavigators: (navigators: Navigators) => void,\n    actionToNavigation: ActionToNavigation,\n    navigationToAction: NavigationToAction,\n  },\n}\n\nexport type ScrollBehavior = Object\n\nexport type Params = { [string]: any }\nexport type Payload = Object\n\nexport type LocationState = {\n  type: string,\n  kind: ?string,\n  query?: Object,\n  prev: Location,\n  search?: string,\n  universal?: true,\n  pathname: string,\n  payload: Payload,\n  routesMap: Routes,\n  history: ?HistoryData,\n}\n\nexport type Location = {\n  pathname: string,\n  type: string,\n  payload: Payload,\n  query?: Object,\n  search?: string,\n}\n\nexport type ActionMetaLocation = {\n  current: Location,\n  prev: Location,\n  from: string,\n  kind: ?string,\n  history: ?HistoryData,\n}\n\nexport type NavigationAction = {\n  type: string,\n  key?: ?string,\n  navKey?: ?string,\n  routeName?: string,\n  actions?: Array<NavigationAction>,\n  action?: NavigationAction,\n  params?: Object,\n  meta?: Object,\n}\n\nexport type Meta = {\n  location: ActionMetaLocation,\n  notFoundPath?: string,\n  navigation?: NavigationAction,\n  query?: Object,\n  search?: string,\n}\n\nexport type HistoryData = {\n  entries: Array<{ pathname: string }>,\n  index: number,\n  length: number,\n}\n\nexport type HistoryRouteAction = {\n  payload: {\n    args: Array<mixed>,\n    method: string,\n  },\n  type: string,\n}\n\nexport type Action = {\n  meta: Meta,\n  type: string,\n  kind?: ?string,\n  query?: Object,\n  payload: Payload,\n  navKey?: ?string,\n  tmp?: Object,\n}\n\nexport type CreateReducerAction = {\n  type: string,\n  basename?: string,\n  hash?: string,\n  location?: SelectLocationState,\n  params?: Object,\n  state?: Object,\n}\n\nexport type ReceivedAction = {\n  type: string,\n  meta?: Object,\n  hash?: string,\n  state?: Object,\n  query?: Object,\n  search?: string,\n  params?: Params,\n  payload?: Payload,\n  navKey?: ?string,\n  basename?: ?string,\n  pathname?: string,\n}\n\nexport type ReceivedActionMeta = {\n  type: string,\n  payload: Payload,\n  query?: Object,\n  navKey?: ?string,\n  meta: {\n    notFoundPath?: string,\n    query?: Object,\n    search?: string,\n  },\n}\n\nexport type Listener = (HistoryLocation, HistoryAction) => void\nexport type Listen = (Listener) => void\nexport type Push = (pathname: string, state?: any) => void\nexport type Replace = (pathname: string, state?: any) => void\nexport type GoBack = () => void\nexport type GoForward = () => void\nexport type Go = (number) => void\nexport type CanGo = (number) => boolean\nexport type BlockFunction = (location: HistoryLocation) => any | Promise<any>\n\nexport type History = {\n  listen: Listen,\n  push: Push,\n  replace: Replace,\n  goBack: GoBack,\n  goForward: GoForward,\n  go: Go,\n  canGo: CanGo,\n  entries: Array<{ pathname: string }>,\n  index: number,\n  length: number,\n  location: HistoryLocation,\n  block: (func: BlockFunction) => void,\n}\n\nexport type LocationActionMeta = {\n  url: string,\n  status: number,\n  kind?: string,\n  from?: string,\n}\n\nexport type LocationAction = {\n  location: LocationActionMeta,\n}\n\nexport type RequestAPI = {\n  cache: {\n    isCached: Function,\n    cacheAction: Function,\n    clear: Function,\n  },\n  routes: Routes,\n  resolveFirstRouteOnEnter: boolean,\n  dispatch: Dispatch,\n  getLocation: Function,\n  getState: GetState,\n  ctx: Object,\n  has: Function,\n  register: Function,\n  options: Options,\n  history: () => {\n    routes: Routes,\n    options: Options,\n    firstAction: Action,\n    dispatch: Dispatch,\n    getLocation: Function,\n  },\n}\n\nexport type HistoryLocation = {\n  pathname: string,\n  search?: string,\n  hash?: string,\n}\n\nexport type AddRoutes = {\n  action: Action,\n  options: Options,\n  routes: Routes,\n  has: Function,\n}\n\nexport type ClearCache = {\n  action: Action,\n  cache: Cache,\n  has: Function,\n}\n\nexport type CallHistory = {\n  routes: Routes,\n  options: Options,\n  firstAction: Action,\n}\n\nexport type HistoryActionDispatcher = {\n  dispatch: Dispatch,\n  action: Action,\n  history: CallHistory,\n  has: Function,\n}\n\nexport type HistoryAction = string\n\nexport type Document = Object\n\nexport type Store = ReduxStore<*, *>\n\nexport type CreateActionsOptions = {\n  logExports: ?boolean,\n  scene: ?string,\n  basename: ?string,\n}\n\nexport type Confirm = {\n  action: Action,\n  ctx: Object,\n  has: Function,\n  _dispatched?: boolean,\n}\n\nexport type Cache = {\n  isCached: Function,\n  cacheAction: Function,\n  clear: Function,\n}\n\nexport type ComposeCurryArgs = Redirect\n\nexport type Prev = {\n  type: string,\n  hash: string,\n  query: Object,\n  state: Object,\n  params: Params,\n  basename: string,\n  location: SelectLocationState,\n}\n\nexport type RequestAction = {\n  type: string,\n  hash: string,\n  query: Object,\n  commit: Action,\n  params: Params,\n  location: LocationState,\n}\n"],"file":"flow-types.js"}